# ThreadMaster

## Что это за проект

Это моя реализация собственного пула потоков на языке Java. Я сделал это вместо использования стандартного `ThreadPoolExecutor`, чтобы лучше понять, как устроено управление потоками и задачами в реальных высоконагруженных приложениях.

Проект состоит из:
- самого пула (`CustomThreadPoolExecutor`);
- кастомной фабрики потоков (`CustomThreadFactory`);
- интерфейса управления (`CustomExecutor`);
- демонстрационной программы (`Main`);
- конфигурации логов (`logback.xml`);
- и файла зависимостей (`pom.xml`).

---

## Что умеет пул

Пул потоков был написан с нуля и поддерживает:

- **Настройки, которые можно задать**:
  - `corePoolSize`: сколько потоков должно быть постоянно.
  - `maxPoolSize`: максимальное количество потоков.
  - `keepAliveTime` + `timeUnit`: сколько времени поток может быть без работы, прежде чем он завершится.
  - `queueSize`: сколько задач может стоять в очереди.
  - `minSpareThreads`: запасные потоки, которые должны быть на готове, даже если нагрузки немного.
  - `numberOfQueues`: сколько очередей использовать для равномерного распределения задач.

- **Обработка задач**:
  - Если задача не помещается в очередь, она отклоняется (об этом будет лог).
  - Задачи распределяются по очередям с помощью алгоритма Round Robin.

- **Создание потоков**:
  - Используется `CustomThreadFactory`, которая даёт потоку имя и выводит в лог, когда поток создаётся.

- **Логирование**:
  - Все важные события записываются: создание и завершение потоков, постановка задач, их выполнение, отклонение, таймаут простоя.

---

## Как всё устроено

### Интерфейс CustomExecutor

Мой пул реализует интерфейс:

```java
public interface CustomExecutor extends Executor {
    void execute(Runnable command);
    <T> Future<T> submit(Callable<T> callable);
    void shutdown();
    void shutdownNow();
}
```

Он нужен для удобного запуска задач и совместимости с Java API (`CompletableFuture` и др.).

---

## Как это работает

1. Есть несколько очередей задач.
2. Каждая задача кладётся в очередь по кругу (`Round Robin`).
3. Потоки читают из очередей и выполняют задачи.
4. Если поток долго ничего не делает, и его можно убрать (по `keepAliveTime`), он завершится.
5. Если все очереди заняты, и нельзя создать новые потоки — задача отклоняется, и это видно в логах.

---

## Как запустить

1. Установите JDK 21 и Maven.
2. Клонируйте репозиторий.
3. Откройте терминал и выполните:

```bash
mvn clean compile
java -cp target/classes org.example.Main
```

В терминале появятся логи, которые показывают, как создаются потоки, как задачи выполняются и что происходит, когда ресурсов не хватает.

---

## Демонстрация

В классе `Main.java` настроен пул вот так:

```java
new CustomThreadPoolExecutor(
    2,                // минимум 2 потока
    4,                // максимум 4 потока
    5,                // потоки простаивают до 5 секунд
    TimeUnit.SECONDS, // время измеряется в секундах
    5,                // очередь задач максимум 5
    2,                // 2 запасных потока
    2                 // 2 очереди задач
);
```

Затем создаются 15 задач. Каждая из них "работает" 2 секунды. Некоторые задачи будут выполнены, другие отклонены (если все очереди и потоки заняты).

---

## Принятые решения

- **Round Robin** — простой способ распределения задач по очередям, даёт равномерную загрузку.
- **Отклонение задач при перегрузке** — это безопасный способ, чтобы приложение не зависло и не упало.
- **Логирование через SLF4J + Logback** — чтобы видеть, что происходит.

## Анализ производительности

- **Плюсы по сравнению с ThreadPoolExecutor**:
  - Гибкость: можно задавать дополнительные параметры, как `minSpareThreads`.
  - Я сам контролирую распределение задач, а не полагаюсь на "чёрный ящик".
  - Уровень логирования выше — легко отслеживать, что происходит.

- **Минусы**:
  - В `ThreadPoolExecutor` всё уже оптимизировано.
  - Мой код требует больше тестирования и может быть менее производителен при больших нагрузках.

---

## Небольшой эксперимент

Если уменьшить `queueSize` до 2 и `maxPoolSize` до 3, часть задач начнёт отклоняться раньше. Если увеличить `minSpareThreads`, то потоков станет больше, даже если очереди почти пустые — это помогает при всплесках нагрузки.

---

## Заключение

Этот проект помог мне лучше понять, как работает многопоточность в Java и как можно управлять задачами вручную. Такие знания пригодятся при написании реальных серверных приложений.



